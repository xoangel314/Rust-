所有权（Ownership）和借用（Borrowing）

并发编程（Concurrency）:

错误处理（Error Handling）:
Result和Option类型来处理可能的错误。
异步编程（Async Programming）:

了解如何使用async和await关键字，以及异步函数和未来的（Futures）概念，

Rust的标准库如集合、迭代器、文件操作等。

### 泛型
1. 理解：同一个函数，支持不同的类型

2. 用法：
   ```
    struct Data<T>  //struct 结构体名称<T>
    {  
       value:T,     //元素：T
    }
    
    fn main() {
        let t:Data<i32> = Data{value:100};
        println!("值:{} ",t.value);//输出 值:100
        let t:Data<f64> = Data{value:66.00};
        println!("值:{} ",t.value);//输出 值:66
    }
   ```

 3. 题目：[错题](链接地址)

### Trait
1. 理解：让不同的类型都分别实现一个特质（比如让不同动物类型分别定义自己的“叫声”方法）

2. 用法：
   ```
      trait Animal    // 定义一个特质 Animal
      {
          fn make_sound(&self);
      }
      
      struct Dog;    // 定义一个狗类型并实现 Animal 特质
      impl Animal for Dog
      {
          fn make_sound(&self) {
              println!("Woof!");
          }
      }
      
      struct Cat;    // 定义一个猫类型并实现 Animal 特质
      impl Animal for Cat
      {
          fn make_sound(&self) {
              println!("Meow!");
          }
      }
    
      // 使用特质方法
      fn main() {
          let dog = Dog;
          let cat = Cat;
          // 调用各个类型的 make_sound 方法
          dog.make_sound();
          cat.make_sound();
      }

   ```

### match模式匹配

   1. 理解:类比厨师面对不同的顾客订单，需要做出不同的菜肴。Rust 中，match就像是一个多路选择器，它允许你根据某个值的多种可能性来执行不同的代码分支。

   2. 基本语法：
    ```
    fn main()
    {
          let shape = "circle";
      
          match shape
         {
              "rectangle" => println!("A rectangle has 4 corners."),
              "circle" => println!("A circle is round."),
              "triangle" => println!("A triangle has 3 corners."),
              _ => println!("Unknown shape."),    //"_"表示任何值，意味着如果以上匹配都不成功，则执行这条
          }
      }
    ```
   3. 其他用法：
      - 赋值：match本身也是一个表达式，因此可以用它来赋值
        ```
        enum IpAddr
        {
         Ipv4,
         Ipv6
        }
      
        fn main()
        {
             let ip1 = IpAddr::Ipv6;
             let ip_str = match ip1
             {
                 IpAddr::Ipv4 => "127.0.0.1",
                 _ => "::1",    //因为这里匹配到 _ 分支，所以将 "::1" 赋值给了 ip_str
             };
         
             println!("{}", ip_str);
         }
        ```
       - match 的匹配必须穷尽所有情况不然会报错。
     
 ### if let
 
   1. 理解：假设你在玩一个猜谜游戏，你只想在猜中特定的答案时才做出反应。if let 是 match 的一个简化版，它只在匹配成功时执行代码块，而不是在所有可能性上进行比较
    
   2. 用法：
       ```
       fn main()
       {
          let option_value = Some(42);
      
          if let Some(7) = option_value {
              println!("Found the lucky number 7!");
          } else {
              println!("The value was not 7.");  //print this
          }
       }
       ```
       
 ### 错误处理

    1. 理解：

    2. 用法：

    3.


